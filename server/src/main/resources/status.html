{% extends "layout.html" %}

{% block title %} Status {% endblock %}

{% block content %}

<div class="card my-4">
    <div class="card-body">
        <h2>Status</h2>

        <p>MARK version {{ status.get("version") }}</p>

        <p>Load: {{ status.get("load") }} ({{ status.get("processors") }} processors)</p>
        <p>
            Memory:
            {{ status.get("memory.used") | numberformat("#") }}MB
            ({{ status.get("memory.total") | numberformat("#") }}MB available)
        </p>

        <p>Running: {{ status.get("running") }}</p>

        <div class='my-4'>
            {% if (status.get("running")) %}
            <a href="/status/pause" class="btn btn-warning">
                <i class="fas fa-pause"></i> Pause
            </a>
            {% else %}
            <a href="/status/resume" class="btn btn-success">
                <i class="fas fa-play"></i> Resume
            </a>
            {% endif %}
        </div>

        <canvas id="chart-history-memory" class='my-4'></canvas>
    </div>
</div>

<div class="card my-4">
    <div class="card-body">
        <h2>Executor Status</h2>

        <p>Executed jobs: {{ status.get("executor.job.executed") }}</p>
        <p>Running jobs: {{ status.get("executor.job.running") }}</p>
        <p>Waiting jobs: {{ status.get("executor.job.waiting") }}</p>


        <p>Job wait time: {{ status.get("executor.job.waittime") | numberformat("#") }}ms</p>
        <p>Job execution time: {{ status.get("executor.job.executetime") | numberformat("#") }}ms</p>

        <p>Total nodes: {{ status.get("executor.nodes") }}</p>
        <p>Total CPU's: {{ status.get("executor.cpus") }}</p>

        <canvas id="chart-history-job-executetime" class='my-4'></canvas>
    </div>
</div>



<div class="card my-4">
    <div class="card-body">
        <h2>DB Status</h2>

        <table class='table table-striped'>
            <tr>
                <th></th>
                <th>Records</th>
                <th>Size (MB)</th>
            </tr>

            <tr>
                <th>Data</th>
                <td>{{ status.get("db.data.count") }}</td>
                <td>{{ status.get("db.data.size") | numberformat("#") }}</td>
            </tr>

            <tr>
                <th>Evidence</th>
                <td>{{ status.get("db.evidence.count") }}</td>
                <td>{{ status.get("db.evidence.size") | numberformat("#") }}</td>
            </tr>
        </table>
    </div>
</div>

<h2>Activation cascade</h2>
<div id="activation-graph"></div>

<div class="text-muted bottom-right">
    Reload in <span id="reload-countdown">60</span> seconds
</div>

<script>

window.colors = {
    red: 'rgba(255, 99, 132, 0.4)',
    orange: 'rgba(255, 165, 0, 0.6)',
    yellow: 'rgba(255, 205, 86, 0.4)',
    green: 'rgba(0, 178, 0, 0.6)',
    blue: 'rgba(54, 162, 235, 0.4)',
    purple: 'rgba(153, 102, 255, 0.4)',
    grey: 'rgba(201, 203, 207, 0.4)'
};

window.colorNames = Object.keys(window.colors);

window.transparent = "rgba(255, 255, 255, 0.0)";

// ------ job execution time
var ctx = document.getElementById('chart-history-job-executetime').getContext('2d');
var chart = new Chart(ctx, {
    // The type of chart we want to create
    type: 'line',

    // The data for our dataset
    data: {
        datasets: [{
            borderColor: colors.blue,
            backgroundColor: transparent,
            data: {{ history_job_executetime | raw }},
            label: 'Job execution time'},
        {
            borderColor: colors.orange,
            backgroundColor: transparent,
            data: {{ history_job_waittime | raw }},
            label: 'Job wait time'
        }]
    },

    // Configuration options go here
    options: {
        legend: {
            display: true,
        },
        elements: {
            line: {
                tension: 0 // disables bezier curves
            }
        },
        scales: {
            xAxes: [{
                type: 'time',
                display: true,
                scaleLabel: {
                        display: true,
                        labelString: 'Time'
                }
            }],
            yAxes: [{
                ticks: {
                    beginAtZero:true
                },
                scaleLabel: {
                    display: true,
                    labelString: 'Time [ms]'
                }
            }]
        }
    }
});

// ------ load and memory
ctx = document.getElementById('chart-history-memory').getContext('2d');
chart = new Chart(ctx, {
    // The type of chart we want to create
    type: 'line',

    // The data for our dataset
    data: {
        datasets: [{
            borderColor: colors.blue,
            backgroundColor: transparent,
            data: {{ history_memory | raw }},
            label: 'Memory usage',
            yAxisID: 'memory',
        },
        {
            borderColor: colors.orange,
            backgroundColor: transparent,
            data: {{ history_load | raw }},
            label: 'Load',
            yAxisID: 'load',
        }]
    },

    // Configuration options go here
    options: {
        legend: {
            display: true
,        },
        elements: {
            line: {
                tension: 0 // disables bezier curves
            }
        },
        scales: {
            xAxes: [{
                type: 'time',
                display: true,
                scaleLabel: {
                        display: true,
                        labelString: 'Time'
                }
            }],
            yAxes: [{
                id: 'memory',
                ticks: {
                    beginAtZero:true
                },
                scaleLabel: {
                    display: true,
                    labelString: 'Used memory [MB]'
                }
            },
                {
                id: 'load',
                ticks: {
                    beginAtZero:true
                },
                position: 'right',
                scaleLabel: {
                    display: true,
                    labelString: 'Load'
                }
            }]
        },
        annotation: {
            annotations: [
                {
                    label: {
                        content: 'Available memory',
                        backgroundColor: colors.blue,
                        yAdjust: 20,
                        xAdjust: -50,
                        enabled: true,
                    },
                    drawTime: 'afterDraw', // overrides annotation.drawTime if set
                    type: 'line',
                    mode: 'horizontal',
                    scaleID: 'memory',
                    value: {{ (status.get("memory.total") / 1024 / 1024) | numberformat("#") }},
                    borderColor: colors.blue,
                    borderWidth: 2
                },
                {
                    label: {
                        content: 'CPUs',
                        backgroundColor: colors.orange,
                        yAdjust: 20,
                        xAdjust: 50,
                        enabled: true,
                    },
                    drawTime: 'afterDraw', // overrides annotation.drawTime if set
                    type: 'line',
                    mode: 'horizontal',
                    scaleID: 'load',
                    value: {{ status.get("processors") }},
                    borderColor: colors.orange,
                    borderWidth: 2
                }
            ]
        }
    }
});
</script>

<script type="text/javascript">
    var reload_countdown = 60;
    setInterval(function() {
        reload_countdown -= 1;
        $('#reload-countdown').text(reload_countdown);

        if (reload_countdown === 0) {
            console.log('reload...');
            location.reload();
        }
    }, 1000);
</script>

<script src="/js/viz.js"></script>
<script>
    var mark_url = "{{ mark.getURL() }}";
    var json_request_body = {"jsonrpc": "2.0",
        "method": "activation",
        "params": {},
        "id": 123
    };

    var request = new XMLHttpRequest();
    request.open('POST', mark_url, true);
    request.setRequestHeader(
            'Content-Type',
            'application/x-www-form-urlencoded; charset=UTF-8');
    request.addEventListener('load', function() {
        if (request.readyState == 4 && request.status == 200) {
            // Request succeeded => draw graph
            var json_response = JSON.parse(request.responseText);
            draw(json_response.result);
        } else {

        }
    });

    request.send(JSON.stringify(json_request_body));

    function draw(detection_agents) {

        // each detection agent has following attributes:
        // - label
        // - trigger_label
        // - class_name

        // Describe the graph using graphviz dot notation
        // 1. Add the nodes (the agents)
        var graph_src = 'digraph G { rankdir=LR; node [fontsize=13, shape=box]; ';
        detection_agents.forEach(function(detection_agent){
            console.log(detection_agent);
            graph_src += '"' + detection_agent.label +  '" [label="'
                    + detection_agent.className + '\n'
                    + detection_agent.label + '"];\n';
        });

        // 2. Add the edges
        detection_agents.forEach(function(detection_agent){
            var matches = 0;
            detection_agents.forEach(function(other){
                if (other.label.startsWith(detection_agent.triggerLabel)) {
                    graph_src += '"' + other.label + '" -> "'
                        + detection_agent.label + '"; ';
                    matches++;
                }
            });

            // We found no agent that will trigger this detection agent
            // => must be a data agent
            // => draw manually...
            if (matches === 0) {
               graph_src += '"' + detection_agent.triggerLabel + '" -> "'
                    + detection_agent.label + '"; ';
            }

        });


        graph_src += '}';

        console.log(graph_src);

        // let graphviz compute the graph representation
        var graph_graphviz = Viz(graph_src);

        // inject the graph svg in the page
        var parser = new DOMParser();
        var graph_svg = parser.parseFromString(graph_graphviz, "image/svg+xml");
        document.querySelector("#activation-graph")
                .appendChild(graph_svg.documentElement);
    }

</script>

{% endblock %}
